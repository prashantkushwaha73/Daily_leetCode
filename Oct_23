*****************************************************************************
**** 557. Reverse Words in a String III ( 01/10/23 ) ****

class Solution {
public:

void reverse(string& str)
{
    int n = str.length();
 
    // Swap character starting from two
    // corners
    for (int i = 0; i < n / 2; i++)
        swap(str[i], str[n - i - 1]);
}

    string reverseWords(string s) {
        string str="";
        string ans="";
        string r;
        for(int i=0;i<s.size();i++){
           if(s[i]==' '){
         reverse(str);
           ans = ans + str;
           ans.push_back(' ');
           str="";
           }
           else{
               str.push_back(s[i]);
           }
        }
         reverse(str);
         ans = ans + str;
         
         return ans;
    }
};

*****************************************************************************************************
**** 2038. Remove Colored Pieces if Both Neighbors are the Same Color ( 02/10/23 ) ****

class Solution {
public:
   
    bool solve(string& s,bool& turn,int& a,int& b,int& size){
        if(turn){
              if(a >= size-1){
                  return !turn;
              }
        }
        else{
            if(b >= size-1){
                return !turn;
            }
        }
        
        while(1){
            if(turn){
                if(s[a-1]=='A' && s[a]=='A' && s[a+1]=='A'){
                    a+=1;
                    if(turn){
                        turn = false;
                    }
                    else{
                        turn = true;
                    }
                    return solve(s,turn,a,b,size);
                }
                else{
                  a+=1;
                  
                  return solve(s,turn,a,b,size);
                }
            }
            else{
               if(s[b-1]=='B' && s[b]=='B' && s[b+1]=='B'){
                    b+=1;
                    if(turn){
                        turn = false;
                    }
                    else{
                        turn = true;
                    }
                    return solve(s,turn,a,b,size);
                }
                else{
                  b+=1;
                  return solve(s,turn,a,b,size);
                }
            }
        }
        return !turn;
    }

    bool winnerOfGame(string colors) {
        bool turn = true;
        int a =1,b=1,size=colors.size();
        return solve(colors,turn,a,b,size);
    }
};

***********************************************************************************************************
**** 1512. Number of Good Pairs ( 03/10/23 ) ****

class Solution {
public:
    int numIdenticalPairs(vector<int>& nums) {
        int ans = 0;
        for(int i=0;i<nums.size();i++){
            for(int j=i+1;j<nums.size();j++){
                if(nums[i]==nums[j]){
                    ans++;
                }
            }
        }
        return ans;
    }
};

**************************************************************************************************
**** 706. Design HashMap ( 04/10/23 ) ****

class MyHashMap {
public:
  int v[1000001];
    MyHashMap() {
        fill(v,v+1000000,-1);
    }
    
    void put(int key, int value) {
        v[key] = value;
    }
    
    int get(int key) {
        return v[key];
    }
    
    void remove(int key) {
        v[key] = -1;
    }
};

***************************************************************************************************
**** 229. Majority Element II ( 05/10/23 ) ****

class Solution {
public:
    vector<int> majorityElement(vector<int>& nums) {
        unordered_map<int,int> m;
        for(int i=0;i<nums.size();i++){
            m[nums[i]]++;
        }
        vector<int> ans;
        for(auto i:m){
            if(i.second > nums.size()/3){
                ans.push_back(i.first);
            }
        }
        return ans;
    }
};

**************************************************************************************************
**** 34. Find First and Last Position of Element in Sorted Array ( 09/10/23 ) ****

class Solution {
    int first(vector<int>& nums,int v){
        int s = 0,e = nums.size()-1;
        int mid ;
        while(s <= e){
          mid = s+(e-s)/2;
          if(nums[mid] == v){
               if(s+1==e){
                  return s;
              }
              e = mid;
              if(s==e){
                  return s;
              }
             
          }
          else if(nums[mid] > v){
              e = mid-1;
          }
          else{
              s = mid+1;
          }
        }
        return -1;
    }

    int last(vector<int>& nums,int v){
        int s = 0,e = nums.size()-1;
        int mid ;
        while(s <= e){
          mid = s+(e-s)/2;
          if(nums[mid] == v){
              if(s+1 == e){
                  if(nums[e]==v){
                      return e;
                  }
                  else{
                      return s;
                  }
              }
              s = mid;
              if(s==e){
                  return e;
              }
        
          }
          else if(nums[mid] > v){
              e = mid-1;
          }
          else{
              s = mid+1;
          }
        }
        return -1;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> ans;
        ans.push_back(first(nums,target));
        ans.push_back(last(nums,target));
        return ans;
    }
};

********************************************************************************************
