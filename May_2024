********************************************************************************************************************************
**** Reverse Prefix of Word ( 01/05/24 ) ****

class Solution {
public:
    string reversePrefix(string word, char ch) {
        for(int i=0;i<word.size();i++){
            if(word[i] == ch){
                string s = word.substr(0,i+1);
                reverse(s.begin(),s.end());
                return s + word.substr(i+1,word.size()-s.size()); 
            }
        }
        return word;
    }
};

***********************************************************************************************************************************
**** Largest Positive Integer That Exists With Its Negative ( 02/05/24 ) ****

class Solution {
public:
    int findMaxK(vector<int>& nums) {
        unordered_map<int,bool> m;
        for(int i=0;i<nums.size();i++){
            if(nums[i]<0){
                m[nums[i]]=true;
            }
        }
        int ans = -1;
        for(int i=0;i<nums.size();i++){
            if(nums[i]>0 && nums[i]>ans && m[-(nums[i])]){
                ans =  nums[i];
            }
        }
        return ans;
    }
};

****************************************************************************************************************************************
**** Delete Node in a Linked List ( 05/05/24 ) ****

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    void deleteNode(ListNode* node) {
        int v = node->val;
        ListNode* temp = node;
        while(temp->next->next){
            temp->val = temp->next->val;
            temp = temp->next;
        }
        temp->val = temp->next->val;
        temp->next->val = v;
        temp->next = NULL;
    }
};

****************************************************************************************************************************************
**** Double a Number Represented as a Linked List ( 07/05/24 ) ****

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* doubleIt(ListNode* head) {
        vector<int>  v;
        ListNode* temp = head;
        while(temp){
            v.push_back(temp->val);
            temp = temp->next;
        }
        vector<int> n;
        int carry = 0;
        for(int i=v.size()-1;i>=0;i--){
            n.push_back( (v[i]*2 + carry)%10 );
            carry = (v[i]*2 + carry)/10;
        }
        while(carry){
            n.push_back(carry%10);
            carry/=10;
        }
       // cout<<v<<endl;
        
        reverse(n.begin(),n.end());
      //  for(int i=0;i<n.size();i++){
       //     cout<<n[i]<<" ";
       // }
        
        if(n.size()){
            head = new ListNode(n[0]);
            temp = head;
        }
        ListNode* ln;
        for(int i=1;i<n.size();i++){
            ln = new ListNode(n[i]);
                temp->next = ln;
            temp = ln;
        }
        return head;
    }
};

****************************************************************************************************************************************
**** Relative Ranks ( 08/05/24 ) ****

class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        priority_queue<int> pq;
        for(int i=0;i<score.size();i++){
            pq.push(score[i]);
        }
        int i=1;
        unordered_map<int,string> m;
        while(!pq.empty()){
            if(i==1){
                m[pq.top()] = "Gold Medal";
            }
            else if(i==2){
                m[pq.top()] = "Silver Medal";
            }
            else if(i==3){
                m[pq.top()] = "Bronze Medal";
            }
            else{
                m[pq.top()] = to_string(i);
            }
            i++; pq.pop();
        }
        vector<string> ans;
        for(int i=0;i<score.size();i++){
            ans.push_back(m[score[i]]);
        }
        return ans;
    }
};

*************************************************************************************************************************************
**** Maximize Happiness of Selected Children ( 09/05/24 ) ****

class Solution {
public:
    long long maximumHappinessSum(vector<int>& arr, int k) {
        priority_queue<int> pq;
        for(int i=0;i<arr.size();i++){
            pq.push(arr[i]);
        }
        int v = 0;
        long long ans = 0;
        while(k){
             if(pq.top()-v > 0){
                ans += (pq.top()-v);
             }
             v++;
             pq.pop();
             k--;
        }
        return ans;
    }
};

*********************************************************************************************************************************************
**** K-th Smallest Prime Fraction ( 10/05/24 ) ****

class Solution {
public:
 
    class Compare {
    public:
       bool operator()(pair<int,int> a, pair<int,int> b){
           if(float(a.first)/float(a.second) < float(b.first)/float(b.second)){
               return true;
           }
           return false;
      }
};

    vector<int> kthSmallestPrimeFraction(vector<int>& arr, int k) {
        priority_queue<pair<int,int>,vector<pair<int,int>>,Compare> pq;
        for(int i=0;i<arr.size();i++){
            for(int j=i+1;j<arr.size();j++){
                    pq.push({arr[i],arr[j]});     
            }
        } 
        int size = pq.size();
        for(int i=0;i<size-k;i++){
            pq.pop();
        }
        return {pq.top().first,pq.top().second};
    }
};

***************************************************************************************************************************************
**** Largest Local Values in a Matrix ( 12/05/24 ) ****

class Solution {
public:

    int solve(int x,int y,vector<vector<int>>& grid){
        int v = INT_MIN;
        for(int i=x-1;i<=x+1;i++){
            for(int j=y-1;j<=y+1;j++){
                v = max(v,grid[i][j]);
            }
        }
        return v;
    }

    vector<vector<int>> largestLocal(vector<vector<int>>& grid) {
        int n = grid.size()-2;
        vector<vector<int>> ans;
        vector<int> p;
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                 p.push_back(solve(i+1,j+1,grid));
            }
            ans.push_back(p);
            p.clear();
        }
        return ans;
     }
};

************************************************************************************************************************************
**** Evaluate Boolean Binary Tree ( 16/05/24 ) ****

class Solution {
public:
    bool solve(TreeNode* root){
        if(root->left==NULL && root->right==NULL){
            if(root->val==0){
                return false;
            }
            else{
                return true;
            }
        }
        if(root->val == 2){
            return solve(root->left)||solve(root->right);
        }
        return solve(root->left)&&solve(root->right);
    }
    bool evaluateTree(TreeNode* root) {
        return solve(root);
    }
};

*********************************************************************************************************************************************
**** Delete Leaves With a Given Value ( 17/05/24 ) ****

class Solution {
public:
    TreeNode* solve(TreeNode* root,int target){
        if(root->left){
            root->left = solve(root->left,target);
        }
        if(root->right){
            root->right = solve(root->right,target);
        }
        if(root->left==NULL && root->right==NULL && root->val==target){
            return NULL;
        }
        return root;
    }

    TreeNode* removeLeafNodes(TreeNode* root, int target) {
        return solve(root,target);
    }
};

**************************************************************************************************************************************************
