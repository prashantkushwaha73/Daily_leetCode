**********************************************************************************
**** 338. Counting Bits ( 01/09/23 ) ***

class Solution {
public:
   
   int solve(int n){
       int count = 0;
       while(n){
           if(n%2){
               count++;
           }
           n/=2;
       }
       return count;
   }

    vector<int> countBits(int n) {
        vector<int> ans;
        for(int i=0;i<=n;i++){
            ans.push_back(solve(i));
        }
        return ans;
    }
};

***************************************************************************************
**** 62. Unique Paths ( 03/09/23 ) ****

class Solution {
public:
  
   int solve(int x,int y,int m,int n,vector<vector<int>>& dp){
       if(dp[x][y] != -1){
           return dp[x][y];
       }
       dp[x][y] = 0;
       ///////// right
       if(y+1 < n){
           dp[x][y] += solve(x,y+1,m,n,dp);
       }
       ///////// down
       if(x+1 < m){
            dp[x][y] += solve(x+1,y,m,n,dp);
       }
       return dp[x][y];
   }

    int uniquePaths(int m, int n) {
        int ans = 0;
        vector<vector<int>> dp;
        vector<int> v;
        for(int j=0;j<n;j++){
            v.push_back(-1);
        }
        for(int i=0;i<m;i++){
            dp.push_back(v);
        }
        dp[m-1][n-1] = 1;
        return solve(0,0,m,n,dp);
    }
};

*************************************************************************************************
**** 141. Linked List Cycle ( 04/09/23 ) ****

class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head==NULL){
            return false;
        }
        if(head->next == NULL){
            return false;
        }
        ListNode* slow=head;
        ListNode* fast=head;
        while(fast!=NULL && slow!=NULL){
            fast=fast->next;
            if(fast!=NULL){
                fast=fast->next;
            }
            slow=slow->next;
            if(slow==fast){
                return true;
            }
        }
        return false;
    }
};

*****************************************************************************************
**** 725. Split Linked List in Parts ( 06/09/23 ) ****

class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        vector<ListNode*> ans;
        int cc=0;
        if(head==NULL){
            while(cc<k){
                ans.push_back(NULL);
                cc++;
            }
            return ans;
        }
        int count=0;
        ListNode* temp=head;
                                // count , How many elements are present in the list
        while(temp!=NULL){
            count++;
            temp=temp->next;
        }
        if(count<=k){
            temp=head;
            ListNode* pemp=head->next;
            while(temp!=NULL){
                temp->next=NULL;
                ans.push_back(temp);
                temp=pemp;
                if(pemp!=NULL){
                pemp=pemp->next; }
            }
            cc=count;
            while(cc<k){
                ans.push_back(NULL);
                cc++;
            }
            return ans;
                                       
        }
        
        ListNode* prev=head;
        ListNode* forw=head->next;
        temp=head;
        cc=0; int p=((count-(count/k)*k)); int m=0,n=0;
        while(cc<k){
            m=1;
            if(p>=1){
                n=(count/k)+1;
            }
            else{
                n=(count/k);
            }
            while(m<n){
                prev=forw;
                forw=forw->next;
                m++;
            }
            prev->next=NULL;
            ans.push_back(temp);
            prev=forw;
            temp=forw;
            if(forw!=NULL){
                forw=forw->next;
            }
            p--;

            cc++;
        }
        return ans;
    }
};

************************************************************************************
**** 118. Pascal's Triangle ( 08/09/23 ) ****

class Solution {
public:
    vector<vector<int>> generate(int numRows) {
       
        int i=0;
        vector<vector<int>> ans;
         if(numRows==0){
            return ans;
        }
        vector<int> fill;
        for(int n=1;n<=numRows;n++){
            if(n==1){
                fill.push_back(1);
                ans.push_back(fill);
                fill.clear();
            }
            else if(n==2){
                fill.push_back(1);
                fill.push_back(1);
                ans.push_back(fill);
                fill.clear();
            }
            else{
                fill.push_back(1);
                for(int i=1;i<n-1;i++){
                    fill.push_back(ans[n-2][i-1] + ans[n-2][i]);
                }
                fill.push_back(1);
                ans.push_back(fill);
                fill.clear();
            }
        }
        return ans;
    }
};

******************************************************************************************************
